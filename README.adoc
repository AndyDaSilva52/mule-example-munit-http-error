= MUnit HTTP Error Handling: A Comprehensive Guide
:toc:
:toc-placement:
:sectnums: |,all|
:source-highlighter: highlight.js
:icons: font

toc::[]

== Introduction
Testing error handling scenarios is a critical aspect of building robust and resilient MuleSoft applications.

When an application interacts with external systems via the HTTP connector, it's not a matter of if an error will occur, but when. Therefore, it's essential to verify that your application can gracefully handle various error responses, such as 4xx client errors or 5xx server errors, and follow the designed compensation logic.

The challenge in testing these paths lies in accurately replicating the complex error object that the MuleSoft HTTP connector generates, which contains a nested structure including status codes, headers, and a payload.

[source,json]
----
{
  "exceptionPayload": null,
  "payload": {
    "message": "Account already exists!"
  },
  "attributes": {
    "headers": {
      "x-correlation-id": "f62f3aad-2d95-42ff-8cd1-6cbba8c8410a",
      "host": "localhost:6075",
      "user-agent": "AHC/1.0",
      "connection": "close",
      "accept": "*/*",
      "content-type": "application/json; charset=UTF-8",
      "content-length": "42",
      "date": "Sat, 27 Sep 2025 21:37:36 GMT"
    },
    "reasonPhrase": "Bad Request",
    "statusCode": 400
  }
}
----

This guide provides a detailed analysis of approaches for mocking and testing HTTP error responses within MUnit 2.

It serves as a reference, offering deep insights into the mechanics, advantages, and disadvantages of each method. The goal is to equip you with the knowledge to choose and implement the most effective and maintainable testing strategy for your projects.

Here a summary of the four options:

* *Option A:* A reusable and high-fidelity approach using a live HTTP listener on a dynamic port to generate realistic, fully-formed error objects. This is the best solution and is well explained.
* *Option B:* A basic, direct approach that tests for expected Mule errors or specific HTTP status codes without needing to mock the connector's internal behavior.
* *Option C:* A more complex variation of Option A that uses a multi-step internal HTTP call structure to achieve a similar result.
* *Option D:* A self-contained approach that uses DataWeave to manually construct a Java Exception object, bypassing the need for a live listener. This option will work, but the `error.errorType` will not complain with the expected `error.errorType` (namespace MULE / identifier UNKNOWN), and it will need a few extra steps to avoid issues in the IDE Anypoint Studio that may show some error in the files.

We will conclude with a detailed comparative analysis and a step-by-step tutorial for implementing the recommended best practice, Option A, which offers the best balance of realism and reusability.

== General Considerations

The base for all of the options (A,B,C or D) is the enabled flows in each munit test.

[source,xml]
----
<munit:enable-flow-sources>
  <munit:enable-flow-source
    value="munit-util-mock-http-error-with-errorMessage-test-suite.http-listener-for-mock-responses" />
  <munit:enable-flow-source
    value="munit-util-mock-http-error-with-errorMessage-test-suite.trigger-mock-http-request" />
</munit:enable-flow-sources>
----

So, it's important to enable the flows that will be used in the test:

ℹ️ You may think in Import the file that has the Flows that are used in the MUnit tests, but this doesn't work very well, so avoid this approach:

[source,xml]
----
<import
    doc:name="Import"
    file="option-a\munit-util-mock-http-request-for-errorMessage-using-listener-localhost-test-suite.xml"
    doc:description="munit-util-mock-http-request-for-errorMessage-using-listener-localhost-test-suite.xml" />
----

When Running in Studio or using maven `mvn clean test` you will need to comment or remove the `import`, otherwise will get an error like:

[source,bash]
----
org.mule.runtime.api.exception.MuleRuntimeException: org.mule.runtime.core.api.config.ConfigurationException: [option-a/munit-util-mock-http-request-for-errorMessage-using-listener-localhost-test-suite.xml:27; option-a\munit-util-mock-http-request-for-errorMessage-using-listener-localhost-test-suite.xml:27]: Two (or more) configuration elements have been defined with the same global name. Global name 'MUnit_HTTP_Listener_config' must be unique.
'munit-util-mock-http-error-with-errorMessage-test-suite.http-listener-for-mock-responses' must be unique.
[option-a/munit-util-mock-http-request-for-errorMessage-using-listener-localhost-test-suite.xml:67; option-a\munit-util-mock-http-request-for-errorMessage-using-listener-localhost-test-suite.xml:67]:
----

=== Dynamic Port

One or more options may use dynamic port feature from MUnit, the official documentation is available on link:https://docs.mulesoft.com/munit/latest/dynamic-ports[Dynamic Ports | MuleSoft Documentation]. Feel free to take a look.

== Reference Guide: Deep Dive into Options
This section provides a detailed breakdown of each of the four testing strategies.

=== Option A: Realistic Mocking with a Utility HTTP Listener

This is the recommended approach for its balance of realism, reusability, and fine-grained control over the mocked error.

See also this Stack Overflow question related to this approach: https://stackoverflow.com/questions/78878885/munits-and-error-handling-how-to-mock-error-error-mulemessage

==== Approach

The core idea is to intercept an outbound `http:request` using a `mock-when` processor and, instead of returning a simple value, redirect the execution to a utility flow within the MUnit test suite using `then-call`.

This utility flow then makes a real HTTP request to a real HTTP listener that is also running as part of the MUnit test on a dynamic port.

This listener is strategically configured to generate a specific HTTP error response (status code, payload, headers). The HTTP connector within the utility flow receives this error response and naturally throws a standard Mule error, which is then propagated back through the mock.

This process creates a highly realistic, fully-structured error object for your test to validate, perfectly mimicking how the connector behaves in a production environment.

==== Diagrams
.Sequence Diagram for Option A
[mermaid]
....
sequenceDiagram
    participant Test as MUnit Test
    participant Flow as Flow Under Test
    participant Mock as Mock When (http:request)
    participant Util as MUnit Utility Flow
    participant Listener as MUnit HTTP Listener

    Test->>Flow: Execute flow
    Flow->>Mock: HTTP Request to external system
    Mock->>Util: then-call utility flow
    Util->>Listener: Makes REAL HTTP request
    Listener-->>Util: Responds with error (e.g., 400 Bad Request + payload)
    Util-->>Mock: Propagates HTTP Connector error
    Mock-->>Flow: Throws realistic error object
    Flow->>Flow: Enters on-error-continue/propagate scope
    Test->>Flow: Verify behavior in error handler
....

.Flowchart for Logic
[mermaid]
....
graph TD
    A[Start Flow] --> B{Try Scope};
    B --> C[http:request];
    C -- Success --> D[Continue Flow];
    C -- Error --> E{On Error Handler};
    E --> F{Condition: error.errorMessage.attributes.statusCode == 400?};
    F -- True --> G[Handle Specific Error Logic];
    G --> D;
    F -- False --> H[Propagate/Default Handling];
    D --> I[End Flow];
....

==== Code Analysis

The implementation utilizes two main flows that can be reused for each munit test case, it's important to mention that for each HTTP Request that you want to mock as error you will need to create or reference a respective flow that defines the structure (status code, payload, headers) you want to thrown.

.common-http-listener-http-request-to-thrown-error
[source,xml]
----
<mule ...>
    <!-- 1. A dynamic port is reserved for the test listener to avoid conflicts. -->
    <munit:dynamic-port propertyName="munit.dynamic.port" />

    <!-- 2. The listener runs on the dynamic port defined above. -->
    <http:listener-config name="MUnit_HTTP_Listener_config">
        <http:listener-connection host="0.0.0.0" port="${munit.dynamic.port}" />
    </http:listener-config>

    <!-- This request config targets the local listener. -->
    <http:request-config name="MUnit_HTTP_Request_configuration">
        <http:request-connection host="localhost" port="${munit.dynamic.port}" />
    </http:request-config>

    <!-- 3. This flow acts as the mock server. It receives requests from the utility flow and generates the desired HTTP response. -->
    <flow name="munit-util-mock-http-error.listener">
        <http:listener
          config-ref="MUnit_HTTP_Listener_config"
          path="/*">
          <http:response
            statusCode="#[(attributes.queryParams.statusCode default attributes.queryParams.httpStatus) default 200]"
            reasonPhrase="#[attributes.queryParams.reasonPhrase]">
            <http:headers><![CDATA[#[attributes.headers]]]></http:headers>
          </http:response>
          <http:error-response
            statusCode="#[(attributes.queryParams.statusCode default attributes.queryParams.httpStatus) default 500]"
            reasonPhrase="#[attributes.queryParams.reasonPhrase]">
            <http:body><![CDATA[#[payload]]]></http:body>
            <http:headers><![CDATA[#[attributes.headers]]]></http:headers>
          </http:error-response>
        </http:listener>

        <logger
          level="TRACE"
          doc:name="doc: Listener Response will Return the payload/http status for the respective request that was made to mock" />
        <!-- The listener simply returns whatever payload it received, but within an error response structure. -->
    </flow>

    <!-- 4. This is the reusable flow called by 'then-call'. Its job is to trigger the listener. -->
    <flow name="munit-util-mock-http-error.req-based-on-vars.munitHttpMock">
        <try doc:name="Try">
          <http:request
            method="#[vars.munitHttpMock.method default 'GET']"
            doc:name="HTTP Req MUnit Listener"
            config-ref="MUnit_HTTP_Request_configuration"
            path="/"
            sendBodyMode="ALWAYS">
            <!-- It passes body, headers and query params from a variable, allowing dynamic control over the mock's response. -->
            <http:body><![CDATA[#[vars.munitRespPayload]]]></http:body>
            <http:headers><![CDATA[#[vars.munitHttpMock.headers default {}]]]></http:headers>
            <http:query-params><![CDATA[#[vars.munitHttpMock.queryParams default {}]]]></http:query-params>
          </http:request>

          <error-handler>
            <on-error-propagate
              enableNotifications="true"
              logException="true"
              doc:name="On Error Propagate">
              <remove-variable
                doc:name="munitHttpMock"
                variableName="munitHttpMock" />
              <remove-variable
                doc:name="munitRespPayload"
                variableName="munitRespPayload" />
            </on-error-propagate>
          </error-handler>
        </try>
        <!-- The error generated by the listener is naturally propagated back to the caller of this flow. -->
    </flow>
</mule>
----

.impl-test-suite.xml
[source,xml]
----
<mule ...>
    <munit:test name="impl-test-suite-test" timeOut="900000">
        <!-- 1. Critical Step: You must enable the utility flows so they can be discovered and called by the MUnit runtime. -->
        <munit:enable-flow-sources>
            <munit:enable-flow-source value="munit-util-mock-http-error-with-errorMessage-test-suite.http-listener-for-mock-responses" />
            <munit:enable-flow-source value="munit-util-mock-http-error-with-errorMessage-test-suite.trigger-mock-http-request" />
        </munit:enable-flow-sources>

        <munit:behavior>
            <munit-tools:mock-when processor="http:request">
                <munit-tools:with-attributes>
                    <!-- Identify the specific http:request instance to intercept. -->
                    <munit-tools:with-attribute whereValue="HTTP_Request_configuration_External" attributeName="config-ref" />
                </munit-tools:with-attributes>
                <!-- 2. Instead of returning a value, instruct the mock to call our setup flow. -->
                <munit-tools:then-call flow="impl-test-suite.setup-mock-for-400-error" />
            </munit-tools:mock-when>
        </munit:behavior>

        <munit:execution>
            <flow-ref name="impl-for-option-a.health-check-and-error-handling" />
        </munit:execution>
        ...
    </munit:test>

    <!-- 3. This flow acts as a test-specific setup, preparing the data for the mock. -->
    <flow name="impl-test-suite.mock-http-req-external-400.flow">
      <ee:transform
        doc:name="munitHttpMock {queryParams: statusCode: 400 } } ; munitRespPayload ;"
        doc:id="904f4a7e-b23d-4aed-a4e1-f049c97434ef">
        <ee:message>
        </ee:message>
        <ee:variables>
          <!-- This variable will become the body of the error response. -->
          <ee:set-variable variableName="munitRespPayload"><![CDATA[%dw 2.0
output application/json
---
{
  message: "Account already exists!"
}]]></ee:set-variable>
          <!-- This variable passes the desired status code to the listener via query parameters. -->
          <ee:set-variable variableName="munitHttpMock"><![CDATA[%dw 2.0
output application/java
---
{
  queryParams: {
    statusCode: 400,
  },
}]]></ee:set-variable>
        </ee:variables>
      </ee:transform>
      <!-- 4. Finally, call the reusable utility flow to trigger the mock listener. -->
      <flow-ref
        doc:name="FlowRef req-based-on-vars.munitHttpMock-flow"
        name="munit-util-mock-http-error.req-based-on-vars.munitHttpMock" />
    </flow>
</mule>
----

==== Pros and Cons

.Pros
* *High Fidelity:* Generates a true `error.errorMessage` object, complete with attributes (statusCode, headers) and payload. This is crucial for accurately testing on-error scopes that inspect these details, for instance: `when="#[error.errorMessage.attributes.statusCode == 404]"`.
* *Reusable:* The utility listener and requester flows can be defined once in the same MUnit Test Suite file, promoting a DRY (Don't Repeat Yourself) testing principle.
ℹ️ an isolate and different common file didn't worked for reuse across hundreds of test suites
* *Flexible:* It's trivial to configure different status codes, payloads, and headers on a per-test basis by simply changing the `munitHttpMock` and `munitRespPayload` variable in the test-specific setup flow.
* *Maintainable:* This pattern cleanly separates the test setup logic (what the mock should do) from the test execution and validation, making individual tests much cleaner and easier to understand.

.Cons
* *Initial Setup:* Requires more upfront configuration compared to simpler methods. However, this is a one-time investment for a highly reusable test utility.
* *Complexity:* The interaction between multiple flows (`mock-when` -> setup flow -> utility flow -> listener flow) can be slightly harder for developers new to MUnit to grasp initially.

==== Common Pitfalls & Troubleshooting

[NOTE]

.Error: `Referenced component '...' must be one of stereotypes [MULE:FLOW, MULE:SUB_FLOW]`

This is a common error in MUnit tests. It happens when your test tries to call a flow that the MUnit runtime has not started.

#### **Cause**

By default, MUnit only starts the main flow that is being explicitly tested. If your test code uses a `flow-ref` or a similar component to call an auxiliary flow (like a utility flow or a mocked listener), the test will fail because that other flow isn't running.

#### **Solution**

You need to explicitly tell MUnit to start all required flows for your test.

1.  In your test case, add the `<munit:enable-flow-sources>` block.
2.  Inside this block, list every flow that your test will call using `<munit:enable-flow-source>`.

**Example:**

```xml
<munit:test name="your-main-flow-test">
    ...
    <munit:enable-flow-sources>
        <munit:enable-flow-source value="your-utility-flow-name" />
        <munit:enable-flow-source value="your-mock-listener-flow" />
    </munit:enable-flow-sources>
    ...
</munit:test>
```

#### **Other Recommendations**

  * **Keep Test Flows Together:** It's best practice to define your test and any supporting mock flows within the same MUnit test suite XML file. Referencing flows from different test files can sometimes lead to unexpected behavior.
  * **Avoid using `src/main/mule` for Test Flows:** Avoid placing test-specific flows (especially those with listeners) in your main application source folder (`src/main/mule`). If you do, they might be deployed with your application, count as active flows, and potentially increase your subscription costs. If this is unavoidable, configure your build to exclude these test files from the final deployment package.

[NOTE]
.Two (or more) configuration elements have been defined with the same global name...
====
*Cause:* This error typically happens if you use the `<import>` tag in your MUnit XML file. While it seems like a logical way to include utility flows, it's a trap.

*Solution:* Avoid using `<import>` in MUnit files. You can enable them as needed using `<munit:enable-flow-sources>`.
====

==== Screenshot Placeholders
// Screenshot: The MUnit 'mock-when' configuration showing the 'then-call' pointing to the setup flow.
// Screenshot: The 'munit-util-mock...' file showing the dynamic port, listener, and requester flows on the canvas.
// Screenshot: Debugger view paused in the error handler, showing the structure of the 'error.errorMessage' object with its payload and attributes.

=== Option B: Direct Error and Status Code Validation

This is a simpler, more direct approach suitable for basic validation scenarios where the full content of the error object is not required for the test logic.

Original source code: link:https://help.salesforce.com/s/articleView?id=001117133&type=1[How to test HTTP error in Mule 4 with Munit 2]

In this option is important to consider move the flow for HTTP Listener from `munitusage.xml` in the directory `src\main\mule\option-b` so the flow and the respective configuration goes to `src/test/munit/option-b`.
This avoid any invalid usage or even the deploy on Mule Runtime.

You may add to your `pom.xml` file to ignore the file in the build:

[source,xml]
----
<build>
    <plugins>
        <plugin>
            <!-- INFO: This plugin is not intended to be used like this, but it works. You may need to find another solution and test if it works. -->
            <artifactId>maven-antrun-plugin</artifactId>
            <version>3.1.0</version>
            <executions>
                <execution>
                    <phase>process-resources</phase>
                    <goals>
                        <goal>run</goal>
                    </goals>
                    <configuration>
                        <target>
                            <delete file="${project.build.outputDirectory}/option-b/munitusage.xml" />
                        </target>
                    </configuration>
                </execution>
            </executions>
        </plugin>
    </plugins>
</build>
----


==== Approach

This method involves making a direct `http:request` from within the MUnit test to a live endpoint (running via `enable-flow-sources`) that is expected to fail. You can then test the outcome in two distinct ways:

* *Expected Mule Error:* Configure the `<munit:test>` element with `expectedErrorType="HTTP:NOT_FOUND"`. When the `http:request` receives a 404 response, it will throw this Mule error, and because MUnit was expecting it, the test will pass. This validates that the correct error type is generated.

* *Success Status Validator:* Configure the `http:request` within the test to accept a non-2xx status code (e.g., 404) as a "success" response. This prevents the connector from throwing a Mule error, allowing your test to proceed to the `<munit:validation>` phase where you can assert that `attributes.statusCode` is indeed 404.

==== Diagram
.Sequence Diagram for Option B
[mermaid]
....
sequenceDiagram
    participant Test as MUnit Test
    participant Listener as Live HTTP Listener (in App)

    Test->>Listener: HTTP Request to non-existent path
    Listener-->>Test: Returns 404 Response

    alt Expecting Mule Error
        Test->>Test: HTTP Requester throws HTTP:NOT_FOUND
        Test->>Test: Test passes as error was expected
    else Using Success Validator
        Test->>Test: HTTP Requester treats 404 as success
        Test->>Test: Assert attributes.statusCode == 404
    end
....

==== Code Analysis
.testHTTPNotFound404Error.xml
[source,xml]
----
<mule ...>
    <!-- Test Case 1: Expecting a Mule Error -->
    <munit:test name="testHTTPNotFound404Error-MuleError" expectedErrorType="HTTP:NOT_FOUND">
        <munit:enable-flow-sources>
            <munit:enable-flow-source value="munitusage.http-listener-and-error-propagation" />
        </munit:enable-flow-sources>
        <munit:execution>
            <!-- This request to a non-existent path will fail, triggering the expected error. -->
            <http:request config-ref="HTTP_Request_configuration" path="/NotExist"/>
        </munit:execution>
    </munit:test>

    <!-- Test Case 2: Validating the Status Code Directly -->
    <munit:test name="testHTTPNotFound404Error-HTTPStatusCode">
        <munit:enable-flow-sources>
            <munit:enable-flow-source value="munitusage.http-listener-and-error-propagation" />
        </munit:enable-flow-sources>
        <munit:execution>
            <http:request config-ref="HTTP_Request_configuration" path="/NotExist">
                <!-- This response validator tells the requester not to throw an error for a 404 response. -->
                <http:response-validator>
                    <http:success-status-code-validator values="404" />
                </http:response-validator>
            </http:request>
        </munit:execution>
        <munit:validation>
            <!-- Since no error was thrown, we can now assert the status code from the response attributes. -->
            <munit-tools:assert-equals
                actual="#[attributes.statusCode]"
                expected="#[404]" />
        </munit:validation>
    </munit:test>
</mule>
----

==== Pros and Cons

.Pros
* *Simple:* Very straightforward to set up for basic use cases, requiring minimal MUnit configuration.
* *Direct:* Clearly tests the fundamental behavior of the HTTP listener's error response mapping without any layers of mocking.

.Cons
* *Limited Scope:* This approach doesn't effectively test the error handling logic within a flow's try block. It's primarily for testing the direct response of a listener or a simple request.
* *No Payload/Attribute Control:* You cannot easily test on-error blocks that rely on a specific error payload or custom headers, as the error object generated is minimal or bypassed entirely. For example, a condition like `when="#[error.errorMessage.payload.code == 'E404-USER']"` cannot be tested this way.
* *Requires Live Endpoint:* Relies on having a running flow to test against, which may not always be desirable.

==== Common Pitfalls & Troubleshooting

[NOTE]
.Test Fails Unexpectedly
====
*Cause:* If you are expecting an `HTTP:NOT_FOUND` error but the test fails, it could be because another error is being thrown first, or a response validator is unintentionally interfering with the outcome.

*Solution:* Ensure no other mocks are inadvertently catching your request. When using the `success-status-code-validator`, it is critical that you remove the `expectedErrorType` attribute from the `<munit:test>` element, as you are explicitly telling MUnit not to expect an error.
====

=== Option C: Complex Internal HTTP Call

This option is functionally similar to Option A, in that it produces a high-fidelity error object, but it does so through a more complex and less intuitive setup.

Reference: link:https://wearecommunity.io/communities/integration/articles/1618[Mocking HTTP error response with status code and body in MUnit 2]

==== Approach

Like Option A, this uses `mock-when` with `then-call`. However, instead of a simple utility flow, it calls a flow that makes an HTTP request to yet another MUnit flow that has a listener. This second flow contains logic to `raise-error` with a generic type, which is then caught by its own `on-error-continue` scope where a response is manually constructed. It achieves the same end result as Option A but with extra, often unnecessary, steps and layers of abstraction.

==== Code Analysis

The key difference is the multi-hop internal call, which adds complexity.

.impl-option-c-test-suite.xml
[source,xml]
----
<mule ...>
    <!-- The mock calls the first flow, 'impl-option-c-test-suite.trigger-mock-404-http-request' -->
    <munit-tools:mock-when processor="http:request">
        <munit-tools:then-call flow="impl-option-c-test-suite.trigger-mock-404-http-request"/>
    </munit-tools:mock-when>
    ...
    <!-- This flow's only job is to make another HTTP request to the listener below -->
    <flow name="impl-option-c-test-suite.trigger-mock-404-http-request">
        <http:request config-ref="Test_Error_Status_Codes_HTTP_Request_configuration" path="/mock">
            <http:query-params>
                <![CDATA[#[{ "expectedStatusCode" : 404 }]]]>
            </http:query-params>
        </http:request>
    </flow>

    <!-- This flow listens, raises a generic error, and then manually builds an error response -->
    <flow name="impl-option-c-test-suite.http-listener-for-mock-error-responses">
        <http:listener config-ref="Test_Error_Status_Codes_HTTP_Listener_config" path="/mock">
            <http:error-response statusCode="#[vars.httpStatus default 500]"/>
        </http:listener>
        <raise-error type="TEST:EXCEPTION"/>
        <error-handler>
            <on-error-continue type="TEST:EXCEPTION">
                <set-variable variableName="httpStatus" value="#[attributes.queryParams.expectedStatusCode]" />
                <ee:transform>
                    <!-- Manually sets the error payload that will be returned -->
                </ee:transform>
            </on-error-continue>
        </error-handler>
    </flow>
</mule>
----

==== Pros and Cons

.Pros
* *High Fidelity:* Ultimately produces a realistic error object that can be used to test complex error handling logic.

.Cons
* *Overly Complex:* The two-step internal HTTP call is confusing and adds unnecessary overhead and points of failure. Option A achieves the same high-fidelity result in a much more direct and understandable way.
* *Hard to Maintain:* The logic is spread across multiple, interdependent flows, making it difficult for another developer to follow the execution path and debug any issues with the test itself.

==== Screenshot Placeholders
// Screenshot: A diagram on the Anypoint Studio canvas showing the chain of mocks and internal HTTP calls for Option C.

=== Option D: Manual Java Exception Creation
This approach avoids using live HTTP listeners entirely and instead constructs the required error object directly in DataWeave by instantiating one of the HTTP connector's internal Java classes.

Reference: https://stackoverflow.com/questions/71778157/how-to-raise-a-custom-error-with-internal-payload-error-errormessage-payload-i

==== Approach

The `munit:set-event` or `mock-when` processor is used to create an error. Its `exception` attribute is populated with a DataWeave expression that directly invokes the Java constructor for `ResponseValidatorTypedException`. This is a non-public, internal class used by the HTTP connector when a response validator fails. By calling `::new()`, you can programmatically specify the error description, type, and a manually constructed payload message, effectively building the error object from scratch.

⚠️

==== Diagram
.Sequence Diagram for Option D
[mermaid]
....
sequenceDiagram
    participant Test as MUnit Test
    participant Flow as Flow Under Test
    participant Mock as Mock When (http:request)

    Test->>Flow: Execute flow
    Flow->>Mock: HTTP Request to external system
    Mock->>Mock: then-return with error
    Mock->>Mock: DW executes Java constructor for Exception
    Mock-->>Flow: Throws a constructed error object
    Flow->>Flow: Enters on-error-continue/propagate scope
    Test->>Flow: Verify behavior
....

==== Code Analysis
.httpErrorDynamic.dwl
[source,dataweave]
----
// This DWL script is called to generate the exception object by directly instantiating a Java class.
java!org::mule::extension::http::api::request::validator::ResponseValidatorTypedException::new(
    vars.munitHttpError.description,
    vars.munitHttpError.errorType,
    java!org::mule::runtime::api::message::Message::of(
        java!org::mule::runtime::api::metadata::TypedValue::new(
            write(vars.munitHttpError.payload,'application/json',{indent: false}),
            java!org::mule::runtime::api::metadata::DataType::JSON_STRING
        )
    )
)
----

.impl-option-d-test-suite.xml with referenced file code
[source,xml]
----
<mule ...>
    <flow name="impl-option-d-test-suite.set-error-event-from-file">
        <!-- This processor creates the error by executing the DWL script. -->
        <munit:set-event>
            <munit:error id="HTTP:INTERNAL_SERVER_ERROR" exception="#[${file::option-d/httpError.dwl}]" />
        </munit:set-event>
    </flow>
</mule>
----

.impl-option-d-test-suite.xml with inline code
[source,xml]
----
<mule ...>
    <flow name="impl-option-d-test-suite.set-error-event-from-file">
        <!-- This processor creates the error by executing the DWL script. -->
        <munit:set-event>
            <munit:error
              id="HTTP:INTERNAL_SERVER_ERROR"
              exception="#[java!org::mule::extension::http::api::request::validator::ResponseValidatorTypedException::new(vars.munitHttpError.description,  vars.munitHttpError.errorType, java!org::mule::runtime::api::message::Message::of(  java!org::mule::runtime::api::metadata::TypedValue::new( write(vars.munitHttpError.payload,'application/json',{indent:false}), java!org::mule::runtime::api::metadata::DataType::JSON_STRING ) ) )]" />
        </munit:set-event>
    </flow>
</mule>
----

==== Pros and Cons

.Pros
* *Self-Contained:* No need for extra listener or requester flows. The error generation logic is contained entirely within the mock definition and its associated DataWeave script.
* *Fast:* Avoids the minor network overhead of an actual local HTTP call, making the test execution marginally faster.

.Cons
* *Brittle and Unstable:* This is the most significant drawback. The test directly relies on internal Java classes (`ResponseValidatorTypedException`) of the HTTP connector. These are not part of the public, supported API and could be renamed, moved, or have their constructors changed in any future version of the connector, which would immediately break all tests using this pattern.
* *Incorrect Error Type:* This method often results in a generic `MULE:UNKNOWN` error type being reported as soon the DataWeave executes and the Java class returns the thrown error. Even if you specify an `id` like `HTTP:INTERNAL_SERVER_ERROR`. This makes assertions against `error.errorType` unreliable.
* *Less Realistic:* It's a synthetic simulation of an error, not a genuine one generated by the connector's own internal logic. This means it may miss subtle behaviors or properties present in a real error object.

==== Common Pitfalls & Troubleshooting

[NOTE]

.class java.lang.String cannot be cast to class java.lang.Throwable
[collapsible]

When you find the issue below:

[source,bash,lineenums]
----
org.mule.runtime.api.exception.MuleRuntimeException: org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'impl-option-d-test-suite.set-error-event-from-file': Cannot create inner bean '(inner bean)#4a329eca' of type [org.mule.munit.runner.processors.SetEventProcessor] while setting bean property 'messageProcessors' with key [1]; nested exception is Error creating bean with name '(inner bean)#4a329eca': Failed properties: Failed to convert property value of type 'org.mule.munit.common.api.model.UntypedEventError' to required type 'org.mule.munit.common.api.model.UntypedEventError' for property 'error'; class java.lang.String cannot be cast to class java.lang.Throwable (java.lang.String and java.lang.Throwable are in module java.base of loader 'bootstrap'); nested exception is Failed properties: Failed to convert property value of type 'org.mule.munit.common.api.model.UntypedEventError' to required type 'org.mule.munit.common.api.model.UntypedEventError' for property 'error'; class java.lang.String cannot be cast to class java.lang.Throwable (java.lang.String and java.lang.Throwable are in module java.base of loader 'bootstrap')
Caused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'impl-option-d-test-suite.set-error-event-from-file': Cannot create inner bean
...
Caused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'error_handlingSub_FlowTest': Cannot create inner bean '(inner bean)#2babdabc' of type [org.mule.munit.runner.component.factory.TestProcessorChainFactory_ByteBuddy_org_mule_runtime_core_privileged_processor_chain_MessageProcessorChain] while setting bean property 'processorChains' with key [0]
----

====
*Cause:* This runtime error often points to an issue with the version of the MUnit Maven Plugin being used. Older versions (e.g., 3.4.0) had known issues correctly handling the `exception` attribute in `munit:set-event` when it was populated by a DataWeave script instantiating an object.

*Solution:* Ensure your `pom.xml` is using a recent and stable version of the `munit-maven-plugin` (e.g. 3.5.0, 3.3.0).


The MUnit test suite `test/munit/option-d/docs-mule-set-event-with-error-test-suite.xml` tries to validate the same usage of attribute `exception` to thrown an error based on an example from the official documentation from MuleSoft available on link:https://docs.mulesoft.com/munit/latest/test-mock-errors-cookbook#set-an-event-with-an-error[Set an Event with an Error - Testing and Mocking Errors | MuleSoft Documentation]

[source,xml]
----
<properties>
    <munit.version>3.5.0</munit.version>
</properties>
----
====

== Comparative Analysis & Recommendation

[options="header"]
|===
| Feature | Option A (Recommended) | Option B | Option C | Option D
| Error Realism | Excellent | Low (for internal logic) | Excellent | Fair to Poor
| Control over Error | Excellent | Poor | Excellent | Good
| Setup Complexity | Medium | Low | High | Low
| Reusability | Excellent | Low | Fair | Good (for DWL script)
| Maintainability | High | High | Low | Medium (risk of breakage)
|===

Recommendation: *Option A*

Option A is the clear winner and the recommended best practice for testing HTTP error handling in MUnit. It provides the most realistic simulation of an HTTP error without being overly complex. The error object it produces is identical in structure and metadata to one from a real-world failure, which is paramount for ensuring your error-handling logic is tested accurately and reliably. While it requires a small amount of initial setup for the utility flows, the long-term benefits of reusability, high maintainability, and testing fidelity far outweigh this initial one-time investment, leading to a more robust and professional test suite.

'''

== Tutorial: Step-by-Step Implementation of Option A
This tutorial will guide you through setting up and using the recommended reusable mocking approach.

=== Step 1: Create the MUnit Utility File
First, create a new MUnit Test Suite file that will house the reusable components. This file will become a shared asset for all your tests.

. In `src/test/munit`, create a new MUnit file named `munit-utils-http-error-suite.xml`.
. Add the `munit:dynamic-port`, `http:listener-config`, and `http:request-config` as shown in the code analysis for Option A. Using a dynamic port is best practice as it prevents port conflicts, especially in CI/CD environments where multiple builds may run concurrently.
. Add the two flows to this file:
** `munit-utility-listener-flow`: This will contain the HTTP Listener that runs on the dynamic port. Its sole purpose is to receive a request and immediately respond with an error status, using the query parameters to define the status code.
** `munit-utility-requester-flow`: This will contain the HTTP Request that calls the listener. This is the generic flow that your actual MUnit tests will target with `then-call`.

// Screenshot: The completed utility file on the Anypoint Studio canvas, showing the two flows and global elements.

=== Step 2: Create the Flow to be Tested
Next, create a simple application flow that makes an HTTP call inside a `try` scope so you can test its specific error handler.

.my-app-flow.xml (src/main/mule)
[source,xml]
----
<flow name="processExternalDataFlow">
    <http:listener config-ref="HTTP_Listener_config" path="/process"/>
    <try>
        <http:request method="GET" url="http://external.api/data" config-ref="HTTP_Request_configuration_External"/>
        <error-handler>
            <on-error-continue when="#[error.errorMessage.attributes.statusCode == 400]">
                <logger level="INFO" message="Handling known 400 error."/>
                <set-payload value="#[error.errorMessage.payload]"/>
            </on-error-continue>
        </error-handler>
    </try>
    <logger level="INFO" message="Flow completed."/>
</flow>
----

=== Step 3: Create the MUnit Test
Finally, create the MUnit test for the application flow from Step 2.

. In `src/test/munit`, create a new MUnit file named `my-app-flow-test-suite.xml`.
. Drag in a MUnit Test scope.
. Inside the test, add the `<munit:enable-flow-sources>` block. This is a critical step. Add two `<munit:enable-flow-source>` entries, one for each of the utility flows you created in Step 1.
. In the Behavior section, drag in a `Mock when` processor.
. Configure it to mock the `http:request` processor.
. Use `with-attributes` to target the specific request you want to intercept (e.g., where `config-ref` is `HTTP_Request_configuration_External`). This ensures you don't accidentally mock other HTTP calls.
. Set its behavior to `then-call` a new flow you will create in this same test file. Let's name it `setup-400-bad-request-mock`.
. Create the `setup-400-bad-request-mock` flow outside the test scope. This flow is test-case specific.
. Inside it, use a Transform Message component to set the payload (the body of the error) and the `munitHttpMock` variable (to specify the `statusCode`), just as shown in the Option A code analysis.
. Add a Flow Reference that calls your reusable requester utility flow (`munit-utility-requester-flow`).
. In the Execution section of your test, use a Flow Reference to call your main application flow (`processExternalDataFlow`).
. In the Validation section, drag in a `Verify call` processor.
. Configure it to verify that the logger inside your `on-error-continue` block was called at least once. This positively confirms that your specific error handling logic was executed as expected.

// Screenshot: The complete MUnit test case canvas, showing the 'Mock when' in Behavior, the flow-ref in Execution, and 'Verify call' in Validation.

By following these steps, you have successfully implemented a robust, reusable, and realistic MUnit test for your HTTP error handling logic, creating a maintainable and professional test suite.
