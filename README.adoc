= MUnit HTTP Error Handling: A Comprehensive Guide
:toc:
:toc-placement:
:sectnums:
:source-highlighter: highlight.js
:icons: font

toc::[]

== Introduction
Testing error handling scenarios is a critical aspect of building robust and resilient MuleSoft applications. When an application interacts with external systems via the HTTP connector, it's not a matter of if an error will occur, but when. Therefore, it's essential to verify that your application can gracefully handle various error responses, such as 4xx client errors or 5xx server errors, and follow the designed compensation logic. The challenge in testing these paths lies in accurately replicating the complex error object that the MuleSoft HTTP connector generates, which contains a nested structure including status codes, headers, and a payload.

This guide provides a detailed analysis of four distinct approaches for mocking and testing HTTP error responses within MUnit 2. It serves as a reference for Junior to Mid-Level MuleSoft developers, offering deep insights into the mechanics, advantages, and disadvantages of each method. The goal is to equip you with the knowledge to choose and implement the most effective and maintainable testing strategy for your projects.

This project analyzes four options:

* *Option A:* A reusable and high-fidelity approach using a live HTTP listener on a dynamic port to generate realistic, fully-formed error objects.
* *Option B:* A basic, direct approach that tests for expected Mule errors or specific HTTP status codes without needing to mock the connector's internal behavior.
* *Option C:* A more complex variation of Option A that uses a multi-step internal HTTP call structure to achieve a similar result.
* *Option D:* A self-contained approach that uses DataWeave to manually construct a Java Exception object, bypassing the need for a live listener.

We will conclude with a detailed comparative analysis and a step-by-step tutorial for implementing the recommended best practice, Option A, which offers the best balance of realism and reusability.

== Reference Guide: Deep Dive into Options
This section provides a detailed breakdown of each of the four testing strategies.

=== Option A: Realistic Mocking with a Utility HTTP Listener
This is the recommended approach for its balance of realism, reusability, and fine-grained control over the mocked error.

==== Approach
The core idea is to intercept an outbound `http:request` using a `mock-when` processor and, instead of returning a simple value, redirect the execution to a utility flow within the MUnit test suite using `then-call`. This utility flow then makes a real HTTP request to a real HTTP listener that is also running as part of the MUnit test on a dynamic port. This listener is strategically configured to generate a specific HTTP error response (status code, payload, headers). The HTTP connector within the utility flow receives this error response and naturally throws a standard Mule error, which is then propagated back through the mock. This process creates a highly realistic, fully-structured error object for your test to validate, perfectly mimicking how the connector behaves in a production environment.

==== Diagrams
.Sequence Diagram for Option A
[mermaid]
....
sequenceDiagram
    participant Test as MUnit Test
    participant Flow as Flow Under Test
    participant Mock as Mock When (http:request)
    participant Util as MUnit Utility Flow
    participant Listener as MUnit HTTP Listener

    Test->>Flow: Execute flow
    Flow->>Mock: HTTP Request to external system
    Mock->>Util: then-call utility flow
    Util->>Listener: Makes REAL HTTP request
    Listener-->>Util: Responds with error (e.g., 400 Bad Request + payload)
    Util-->>Mock: Propagates HTTP Connector error
    Mock-->>Flow: Throws realistic error object
    Flow->>Flow: Enters on-error-continue/propagate scope
    Test->>Flow: Verify behavior in error handler
....

.Flowchart for Logic
[mermaid]
....
graph TD
    A[Start Flow] --> B{Try Scope};
    B --> C[http:request];
    C -- Success --> D[Continue Flow];
    C -- Error --> E{On Error Handler};
    E --> F{Condition: error.errorMessage.attributes.statusCode == 400?};
    F -- True --> G[Handle Specific Error Logic];
    G --> D;
    F -- False --> H[Propagate/Default Handling];
    D --> I[End Flow];
....

==== Code Analysis
The implementation is split into two key files: the utility file containing the reusable mock infrastructure, and the test file that consumes it.

.munit-util-mock-http-error-with-errorMessage-test-suite.xml
[source,xml]
----
<mule ...>
    <!-- 1. A dynamic port is reserved for the test listener to avoid conflicts. -->
    <munit:dynamic-port propertyName="munit.dynamic.port" />

    <!-- 2. The listener runs on the dynamic port defined above. -->
    <http:listener-config name="MUnit_HTTP_Listener_config">
        <http:listener-connection host="0.0.0.0" port="${munit.dynamic.port}" />
    </http:listener-config>

    <!-- This request config targets the local listener. -->
    <http:request-config name="MUnit_HTTP_Request_configuration">
        <http:request-connection host="localhost" port="${munit.dynamic.port}" />
    </http:request-config>

    <!-- 3. This flow acts as the mock server. It receives requests from the utility flow and generates the desired HTTP response. -->
    <flow name="munit-util-mock-http-error-with-errorMessage-test-suite.listener-flow">
        <http:listener config-ref="MUnit_HTTP_Listener_config" path="/*">
            <http:error-response statusCode="#[(attributes.queryParams.statusCode default attributes.queryParams.httpStatus) default 500]">
                <http:body>#[payload]</http:body>
            </http:error-response>
        </http:listener>
        <!-- The listener simply returns whatever payload it received, but within an error response structure. -->
    </flow>

    <!-- 4. This is the reusable flow called by 'then-call'. Its job is to trigger the listener. -->
    <flow name="munit-util-mock-http-error-with-errorMessage-test-suite.req-based-on-vars.munitHttpMock-flow">
        <http:request
            method="GET"
            config-ref="MUnit_HTTP_Request_configuration"
            path="/">
            <!-- It passes headers and query params from a variable, allowing dynamic control over the mock's response. -->
            <http:headers>#[vars.munitHttpMock.headers default {}]</http:headers>
            <http:query-params>#[vars.munitHttpMock.queryParams default {}]</http:query-params>
        </http:request>
        <!-- The error generated by the listener is naturally propagated back to the caller of this flow. -->
    </flow>
</mule>
----

.implementation-test-suite.xml
[source,xml]
----
<mule ...>
    <munit:test name="implementation-test-suite-test" timeOut="900000">
        <!-- 1. Critical Step: You must enable the utility flows so they can be discovered and called by the MUnit runtime. -->
        <munit:enable-flow-sources>
            <munit:enable-flow-source value="munit-util-mock-http-error-with-errorMessage-test-suite.listener-flow" />
            <munit:enable-flow-source value="munit-util-mock-http-error-with-errorMessage-test-suite.req-based-on-vars.munitHttpMock-flow" />
        </munit:enable-flow-sources>

        <munit:behavior>
            <munit-tools:mock-when processor="http:request">
                <munit-tools:with-attributes>
                    <!-- Identify the specific http:request instance to intercept. -->
                    <munit-tools:with-attribute whereValue="HTTP_Request_configuration_External" attributeName="config-ref" />
                </munit-tools:with-attributes>
                <!-- 2. Instead of returning a value, instruct the mock to call our setup flow. -->
                <munit-tools:then-call flow="implementation-test-suite.mock-http-req-external-400.flow" />
            </munit-tools:mock-when>
        </munit:behavior>

        <munit:execution>
            <flow-ref name="implementation-for-option-a.subflow" />
        </munit:execution>
        ...
    </munit:test>

    <!-- 3. This flow acts as a test-specific setup, preparing the data for the mock. -->
    <flow name="implementation-test-suite.mock-http-req-external-400.flow">
        <ee:transform>
            <ee:message>
                <!-- This payload will become the body of the error response. -->
                <ee:set-payload>{ "message": "Account already exists!" }</ee:set-payload>
            </ee:message>
            <ee:variables>
                <!-- This variable passes the desired status code to the listener via query parameters. -->
                <ee:set-variable variableName="munitHttpMock">
                    <![CDATA[%dw 2.0
                    output application/java
                    ---
                    { queryParams: { statusCode: 400 } }]]>
                </ee:set-variable>
            </ee:variables>
        </ee:transform>
        <!-- 4. Finally, call the reusable utility flow to trigger the mock listener. -->
        <flow-ref name="munit-util-mock-http-error-with-errorMessage-test-suite.req-based-on-vars.munitHttpMock-flow" />
    </flow>
</mule>
----

==== Pros and Cons

.Pros
* *High Fidelity:* Generates a true `error.errorMessage` object, complete with attributes (statusCode, headers) and payload. This is crucial for accurately testing on-error scopes that inspect these details, for instance: `when="#[error.errorMessage.attributes.statusCode == 404]"`.
* *Reusable:* The utility listener and requester flows can be defined once in a common file and reused across hundreds of test suites, promoting a DRY (Don't Repeat Yourself) testing principle.
* *Flexible:* It's trivial to configure different status codes, payloads, and headers on a per-test basis by simply changing the `munitHttpMock` variable in the test-specific setup flow.
* *Maintainable:* This pattern cleanly separates the test setup logic (what the mock should do) from the test execution and validation, making individual tests much cleaner and easier to understand.

.Cons
* *Initial Setup:* Requires more upfront configuration compared to simpler methods. However, this is a one-time investment for a highly reusable test utility.
* *Complexity:* The interaction between multiple flows (`mock-when` -> setup flow -> utility flow -> listener flow) can be slightly harder for developers new to MUnit to grasp initially.

==== Common Pitfalls & Troubleshooting

[NOTE]
.Referenced component '...' must be one of stereotypes [MULE:FLOW, MULE:SUB_FLOW]
====
*Cause:* This is the most common error encountered with this pattern. It occurs when you use `then-call` or `flow-ref` to invoke a flow from your MUnit test suite, but the MUnit runtime hasn't been instructed to start that flow. By default, MUnit only starts the flow being explicitly tested.

*Solution:* Ensure that every auxiliary flow used by your test—especially the listener and utility flows—is explicitly listed within the `<munit:enable-flow-sources>` block in your test case. This tells MUnit to initialize and start these flows so they are available to be called.
[source,xml]
----
<munit:enable-flow-sources>
    <munit:enable-flow-source value="your-utility-flow-name" />
    <munit:enable-flow-source value="your-listener-flow-name" />
</munit:enable-flow-sources>
----
====

[NOTE]
.Two (or more) configuration elements have been defined with the same global name...
====
*Cause:* This error typically happens if you use the `<import>` tag in your MUnit XML file. While it seems like a logical way to include utility flows, it's a trap. MUnit automatically scans and loads all test files under `src/test/munit`, and importing a file that is already being loaded causes all of its global components (like HTTP configs) to be declared twice.

*Solution:* Avoid using `<import>` in MUnit files. The correct approach is to keep utility flows in their own MUnit XML file within the same directory. MUnit will automatically load them, and you can then enable them as needed using `<munit:enable-flow-sources>`.
====

==== Screenshot Placeholders
// Screenshot: The MUnit 'mock-when' configuration showing the 'then-call' pointing to the setup flow.
// Screenshot: The 'munit-util-mock...' file showing the dynamic port, listener, and requester flows on the canvas.
// Screenshot: Debugger view paused in the error handler, showing the structure of the 'error.errorMessage' object with its payload and attributes.

=== Option B: Direct Error and Status Code Validation
This is a simpler, more direct approach suitable for basic validation scenarios where the full content of the error object is not required for the test logic.

==== Approach
This method involves making a direct `http:request` from within the MUnit test to a live endpoint (running via `enable-flow-sources`) that is expected to fail. You can then test the outcome in two distinct ways:

* *Expected Mule Error:* Configure the `<munit:test>` element with `expectedErrorType="HTTP:NOT_FOUND"`. When the `http:request` receives a 404 response, it will throw this Mule error, and because MUnit was expecting it, the test will pass. This validates that the correct error type is generated.
* *Success Status Validator:* Configure the `http:request` within the test to accept a non-2xx status code (e.g., 404) as a "success" response. This prevents the connector from throwing a Mule error, allowing your test to proceed to the `<munit:validation>` phase where you can assert that `attributes.statusCode` is indeed 404.

==== Diagram
.Sequence Diagram for Option B
[mermaid]
....
sequenceDiagram
    participant Test as MUnit Test
    participant Listener as Live HTTP Listener (in App)

    Test->>Listener: HTTP Request to non-existent path
    Listener-->>Test: Returns 404 Response

    alt Expecting Mule Error
        Test->>Test: HTTP Requester throws HTTP:NOT_FOUND
        Test->>Test: Test passes as error was expected
    else Using Success Validator
        Test->>Test: HTTP Requester treats 404 as success
        Test->>Test: Assert attributes.statusCode == 404
    end
....

==== Code Analysis
.testHTTPNotFound404Error.xml
[source,xml]
----
<mule ...>
    <!-- Test Case 1: Expecting a Mule Error -->
    <munit:test name="testHTTPNotFound404Error-MuleError" expectedErrorType="HTTP:NOT_FOUND">
        <munit:enable-flow-sources>
            <munit:enable-flow-source value="HTTPEndpoint" />
        </munit:enable-flow-sources>
        <munit:execution>
            <!-- This request to a non-existent path will fail, triggering the expected error. -->
            <http:request config-ref="HTTP_Request_configuration" path="/NotExist"/>
        </munit:execution>
    </munit:test>

    <!-- Test Case 2: Validating the Status Code Directly -->
    <munit:test name="testHTTPNotFound404Error-HTTPStatusCode">
        <munit:enable-flow-sources>
            <munit:enable-flow-source value="HTTPEndpoint" />
        </munit:enable-flow-sources>
        <munit:execution>
            <http:request config-ref="HTTP_Request_configuration" path="/NotExist">
                <!-- This response validator tells the requester not to throw an error for a 404 response. -->
                <http:response-validator>
                    <http:success-status-code-validator values="404" />
                </http:response-validator>
            </http:request>
        </munit:execution>
        <munit:validation>
            <!-- Since no error was thrown, we can now assert the status code from the response attributes. -->
            <munit-tools:assert-equals
                actual="#[attributes.statusCode]"
                expected="#[404]" />
        </munit:validation>
    </munit:test>
</mule>
----

==== Pros and Cons

.Pros
* *Simple:* Very straightforward to set up for basic use cases, requiring minimal MUnit configuration.
* *Direct:* Clearly tests the fundamental behavior of the HTTP listener's error response mapping without any layers of mocking.

.Cons
* *Limited Scope:* This approach doesn't effectively test the error handling logic within a flow's try block. It's primarily for testing the direct response of a listener or a simple request.
* *No Payload/Attribute Control:* You cannot easily test on-error blocks that rely on a specific error payload or custom headers, as the error object generated is minimal or bypassed entirely. For example, a condition like `when="#[error.errorMessage.payload.code == 'E404-USER']"` cannot be tested this way.
* *Requires Live Endpoint:* Relies on having a running flow to test against, which may not always be desirable.

==== Common Pitfalls & Troubleshooting

[NOTE]
.Test Fails Unexpectedly
====
*Cause:* If you are expecting an `HTTP:NOT_FOUND` error but the test fails, it could be because another error is being thrown first, or a response validator is unintentionally interfering with the outcome.

*Solution:* Ensure no other mocks are inadvertently catching your request. When using the `success-status-code-validator`, it is critical that you remove the `expectedErrorType` attribute from the `<munit:test>` element, as you are explicitly telling MUnit not to expect an error.
====

=== Option C: Complex Internal HTTP Call
This option is functionally similar to Option A, in that it produces a high-fidelity error object, but it does so through a more complex and less intuitive setup.

==== Approach
Like Option A, this uses `mock-when` with `then-call`. However, instead of a simple utility flow, it calls a flow that makes an HTTP request to yet another MUnit flow that has a listener. This second flow contains logic to `raise-error` with a generic type, which is then caught by its own `on-error-continue` scope where a response is manually constructed. It achieves the same end result as Option A but with extra, often unnecessary, steps and layers of abstraction.

==== Code Analysis
The key difference is the multi-hop internal call, which adds complexity.

.implementation-option-c-test-suite.xml
[source,xml]
----
<mule ...>
    <!-- The mock calls the first flow, 'test-mock-http-call-error-404' -->
    <munit-tools:mock-when processor="http:request">
        <munit-tools:then-call flow="test-mock-http-call-error-404"/>
    </munit-tools:mock-when>
    ...
    <!-- This flow's only job is to make another HTTP request to the listener below -->
    <flow name="test-mock-http-call-error-404">
        <http:request config-ref="Test_Error_Status_Codes_HTTP_Request_configuration" path="/mock">
            <http:query-params>
                <![CDATA[#[{ "expectedStatusCode" : 404 }]]]>
            </http:query-params>
        </http:request>
    </flow>

    <!-- This flow listens, raises a generic error, and then manually builds an error response -->
    <flow name="test-mock-http-call-error-responses">
        <http:listener config-ref="Test_Error_Status_Codes_HTTP_Listener_config" path="/mock">
            <http:error-response statusCode="#[vars.httpStatus default 500]"/>
        </http:listener>
        <raise-error type="TEST:EXCEPTION"/>
        <error-handler>
            <on-error-continue type="TEST:EXCEPTION">
                <set-variable variableName="httpStatus" value="#[attributes.queryParams.expectedStatusCode]" />
                <ee:transform>
                    <!-- Manually sets the error payload that will be returned -->
                </ee:transform>
            </on-error-continue>
        </error-handler>
    </flow>
</mule>
----

==== Pros and Cons

.Pros
* *High Fidelity:* Ultimately produces a realistic error object that can be used to test complex error handling logic.

.Cons
* *Overly Complex:* The two-step internal HTTP call is confusing and adds unnecessary overhead and points of failure. Option A achieves the same high-fidelity result in a much more direct and understandable way.
* *Hard to Maintain:* The logic is spread across multiple, interdependent flows, making it difficult for another developer to follow the execution path and debug any issues with the test itself.

==== Screenshot Placeholders
// Screenshot: A diagram on the Anypoint Studio canvas showing the chain of mocks and internal HTTP calls for Option C.

=== Option D: Manual Java Exception Creation
This approach avoids using live HTTP listeners entirely and instead constructs the required error object directly in DataWeave by instantiating one of the HTTP connector's internal Java classes.

==== Approach
The `munit:set-event` or `mock-when` processor is used to create an error. Its `exception` attribute is populated with a DataWeave expression that directly invokes the Java constructor for `ResponseValidatorTypedException`. This is a non-public, internal class used by the HTTP connector when a response validator fails. By calling `::new()`, you can programmatically specify the error description, type, and a manually constructed payload message, effectively building the error object from scratch.

==== Diagram
.Sequence Diagram for Option D
[mermaid]
....
sequenceDiagram
    participant Test as MUnit Test
    participant Flow as Flow Under Test
    participant Mock as Mock When (http:request)

    Test->>Flow: Execute flow
    Flow->>Mock: HTTP Request to external system
    Mock->>Mock: then-return with error
    Mock->>Mock: DW executes Java constructor for Exception
    Mock-->>Flow: Throws a constructed error object
    Flow->>Flow: Enters on-error-continue/propagate scope
    Test->>Flow: Verify behavior
....

==== Code Analysis
.httpErrorDynamic.dwl
[source,dataweave]
----
// This DWL script is called to generate the exception object by directly instantiating a Java class.
java!org::mule::extension::http::api::request::validator::ResponseValidatorTypedException::new(
    vars.munitHttpError.description,
    vars.munitHttpError.errorType,
    java!org::mule::runtime::api::message::Message::of(
        java!org::mule::runtime::api::metadata::TypedValue::new(
            write(vars.munitHttpError.payload,'application/json',{indent: false}),
            java!org::mule::runtime::api::metadata::DataType::JSON_STRING
        )
    )
)
----

.implementation-option-d-test-suite.xml
[source,xml]
----
<mule ...>
    <flow name="munit-set-error-code-event-flow">
        <!-- This processor creates the error by executing the DWL script. -->
        <munit:set-event>
            <munit:error id="HTTP:INTERNAL_SERVER_ERROR" exception="#[${file::option-d/httpError.dwl}]" />
        </munit:set-event>
    </flow>
</mule>
----

==== Pros and Cons

.Pros
* *Self-Contained:* No need for extra listener or requester flows. The error generation logic is contained entirely within the mock definition and its associated DataWeave script.
* *Fast:* Avoids the minor network overhead of an actual local HTTP call, making the test execution marginally faster.

.Cons
* *Brittle and Unstable:* This is the most significant drawback. The test directly relies on internal Java classes (`ResponseValidatorTypedException`) of the HTTP connector. These are not part of the public, supported API and could be renamed, moved, or have their constructors changed in any future version of the connector, which would immediately break all tests using this pattern.
* *Incorrect Error Type:* As noted in the original README.adoc, this method often results in a generic `MULE:UNKNOWN` error type being reported in the logs, even if you specify an `id` like `HTTP:INTERNAL_SERVER_ERROR`. This makes assertions against `error.errorType` unreliable.
* *Less Realistic:* It's a synthetic simulation of an error, not a genuine one generated by the connector's own internal logic. This means it may miss subtle behaviors or properties present in a real error object.

==== Common Pitfalls & Troubleshooting

[NOTE]
.class java.lang.String cannot be cast to class java.lang.Throwable
====
*Cause:* This runtime error often points to an issue with the version of the MUnit Maven Plugin being used. Older versions (e.g., 3.4.0) had known issues correctly handling the `exception` attribute in `munit:set-event` when it was populated by a DataWeave script instantiating an object.

*Solution:* Ensure your `pom.xml` is using a recent and stable version of the `munit-maven-plugin`. The project uses `3.5.0`, which resolves this issue.
[source,xml]
----
<properties>
    <munit.version>3.5.0</munit.version>
</properties>
----
====

== Comparative Analysis & Recommendation

[options="header"]
|===
| Feature | Option A (Recommended) | Option B | Option C | Option D
| Error Realism | Excellent | Low (for internal logic) | Excellent | Fair to Poor
| Control over Error | Excellent | Poor | Excellent | Good
| Setup Complexity | Medium | Low | High | Low
| Reusability | Excellent | Low | Fair | Good (for DWL script)
| Maintainability | High | High | Low | Medium (risk of breakage)
|===

Recommendation: *Option A*

Option A is the clear winner and the recommended best practice for testing HTTP error handling in MUnit. It provides the most realistic simulation of an HTTP error without being overly complex. The error object it produces is identical in structure and metadata to one from a real-world failure, which is paramount for ensuring your error-handling logic is tested accurately and reliably. While it requires a small amount of initial setup for the utility flows, the long-term benefits of reusability, high maintainability, and testing fidelity far outweigh this initial one-time investment, leading to a more robust and professional test suite.

'''

== Tutorial: Step-by-Step Implementation of Option A
This tutorial will guide you through setting up and using the recommended reusable mocking approach.

=== Step 1: Create the MUnit Utility File
First, create a new MUnit Test Suite file that will house the reusable components. This file will become a shared asset for all your tests.

. In `src/test/munit`, create a new MUnit file named `munit-utils-http-error-suite.xml`.
. Add the `munit:dynamic-port`, `http:listener-config`, and `http:request-config` as shown in the code analysis for Option A. Using a dynamic port is best practice as it prevents port conflicts, especially in CI/CD environments where multiple builds may run concurrently.
. Add the two flows to this file:
** `munit-utility-listener-flow`: This will contain the HTTP Listener that runs on the dynamic port. Its sole purpose is to receive a request and immediately respond with an error status, using the query parameters to define the status code.
** `munit-utility-requester-flow`: This will contain the HTTP Request that calls the listener. This is the generic flow that your actual MUnit tests will target with `then-call`.

// Screenshot: The completed utility file on the Anypoint Studio canvas, showing the two flows and global elements.

=== Step 2: Create the Flow to be Tested
Next, create a simple application flow that makes an HTTP call inside a `try` scope so you can test its specific error handler.

.my-app-flow.xml (src/main/mule)
[source,xml]
----
<flow name="processExternalDataFlow">
    <http:listener config-ref="HTTP_Listener_config" path="/process"/>
    <try>
        <http:request method="GET" url="http://external.api/data" config-ref="HTTP_Request_configuration_External"/>
        <error-handler>
            <on-error-continue when="#[error.errorMessage.attributes.statusCode == 400]">
                <logger level="INFO" message="Handling known 400 error."/>
                <set-payload value="#[error.errorMessage.payload]"/>
            </on-error-continue>
        </error-handler>
    </try>
    <logger level="INFO" message="Flow completed."/>
</flow>
----

=== Step 3: Create the MUnit Test
Finally, create the MUnit test for the application flow from Step 2.

. In `src/test/munit`, create a new MUnit file named `my-app-flow-test-suite.xml`.
. Drag in a MUnit Test scope.
. Inside the test, add the `<munit:enable-flow-sources>` block. This is a critical step. Add two `<munit:enable-flow-source>` entries, one for each of the utility flows you created in Step 1.
. In the Behavior section, drag in a `Mock when` processor.
. Configure it to mock the `http:request` processor.
. Use `with-attributes` to target the specific request you want to intercept (e.g., where `config-ref` is `HTTP_Request_configuration_External`). This ensures you don't accidentally mock other HTTP calls.
. Set its behavior to `then-call` a new flow you will create in this same test file. Let's name it `setup-400-bad-request-mock`.
. Create the `setup-400-bad-request-mock` flow outside the test scope. This flow is test-case specific.
. Inside it, use a Transform Message component to set the payload (the body of the error) and the `munitHttpMock` variable (to specify the `statusCode`), just as shown in the Option A code analysis.
. Add a Flow Reference that calls your reusable requester utility flow (`munit-utility-requester-flow`).
. In the Execution section of your test, use a Flow Reference to call your main application flow (`processExternalDataFlow`).
. In the Validation section, drag in a `Verify call` processor.
. Configure it to verify that the logger inside your `on-error-continue` block was called at least once. This positively confirms that your specific error handling logic was executed as expected.

// Screenshot: The complete MUnit test case canvas, showing the 'Mock when' in Behavior, the flow-ref in Execution, and 'Verify call' in Validation.

By following these steps, you have successfully implemented a robust, reusable, and realistic MUnit test for your HTTP error handling logic, creating a maintainable and professional test suite.
