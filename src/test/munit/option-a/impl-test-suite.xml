<?xml version="1.0" encoding="UTF-8"?>

<mule
  xmlns:http="http://www.mulesoft.org/schema/mule/http"
  xmlns:ee="http://www.mulesoft.org/schema/mule/ee/core"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:munit="http://www.mulesoft.org/schema/mule/munit"
  xmlns:munit-tools="http://www.mulesoft.org/schema/mule/munit-tools"
  xmlns="http://www.mulesoft.org/schema/mule/core"
  xmlns:doc="http://www.mulesoft.org/schema/mule/documentation"
  xsi:schemaLocation="
    http://www.mulesoft.org/schema/mule/core http://www.mulesoft.org/schema/mule/core/current/mule.xsd
    http://www.mulesoft.org/schema/mule/munit http://www.mulesoft.org/schema/mule/munit/current/mule-munit.xsd
    http://www.mulesoft.org/schema/mule/munit-tools  http://www.mulesoft.org/schema/mule/munit-tools/current/mule-munit-tools.xsd
http://www.mulesoft.org/schema/mule/http http://www.mulesoft.org/schema/mule/http/current/mule-http.xsd
http://www.mulesoft.org/schema/mule/ee/core http://www.mulesoft.org/schema/mule/ee/core/current/mule-ee.xsd
http://www.mulesoft.org/schema/mule/validation http://www.mulesoft.org/schema/mule/validation/current/mule-validation.xsd">
  <munit:config name="impl-option-a-test-suite.xml" />

  <!-- 1. A dynamic port is reserved for the test listener to avoid conflicts. -->
  <munit:dynamic-port
    propertyName="munit.dynamic.port"
    min="6000"
    max="7000" />

  <!-- 2. The listener runs on the dynamic port defined above. -->
  <http:listener-config
    name="MUnit_HTTP_Listener_config"
    doc:name="HTTP Listener config">
    <http:listener-connection
      host="0.0.0.0"
      port="${munit.dynamic.port}" />
  </http:listener-config>

  <!-- This request config targets the local listener. -->
  <http:request-config name="MUnit_HTTP_Request_configuration">
    <http:request-connection
      host="localhost"
      port="${munit.dynamic.port}" />
  </http:request-config>

  <!-- 3. This flow acts as the mock server. It receives requests from the utility flow and generates the desired HTTP response. -->
  <flow name="munit-util-mock-http-error.listener">
    <http:listener
      doc:name="Listener"
      config-ref="MUnit_HTTP_Listener_config"
      path="/*">
      <http:response
        statusCode="#[(attributes.queryParams.statusCode default attributes.queryParams.httpStatus) default 200]"
        reasonPhrase="#[attributes.queryParams.reasonPhrase]">
        <http:headers>
          <![CDATA[#[attributes.headers]]]>
        </http:headers>
      </http:response>
      <http:error-response
        statusCode="#[(attributes.queryParams.statusCode default attributes.queryParams.httpStatus) default 500]"
        reasonPhrase="#[attributes.queryParams.reasonPhrase]">
        <http:body>
          <![CDATA[#[payload]]]>
        </http:body>
        <http:headers>
          <![CDATA[#[attributes.headers]]]>
        </http:headers>
      </http:error-response>
    </http:listener>

    <logger
      level="TRACE"
      doc:name="doc: Listener Response will Return the payload/http status for the respective request that was made to mock" />
    <!-- The listener simply returns whatever payload it received, but within an error response structure. -->
  </flow>

  <!-- 4. This is the reusable flow called by 'then-call'. Its job is to trigger the listener. -->
  <flow name="munit-util-mock-http-error.req-based-on-vars.munitHttp">
    <try doc:name="Try">
      <http:request
        config-ref="MUnit_HTTP_Request_configuration"
        method="#[vars.munitHttp.method default 'GET']"
        path="#[vars.munitHttp.path default '/']"
        sendBodyMode="ALWAYS">
        <!-- It passes body, headers and query params from a variable, allowing dynamic control over the mock's response. -->
        <http:body>
          <![CDATA[#[vars.munitBody]]]>
        </http:body>
        <http:headers>
          <![CDATA[#[vars.munitHttp.headers default {}]]]>
        </http:headers>
        <http:query-params>
          <![CDATA[#[vars.munitHttp.queryParams default {}]]]>
        </http:query-params>
      </http:request>
      <!-- The error generated by the listener is naturally propagated back to the caller of this flow. -->
      <error-handler>
        <on-error-propagate doc:name="On Error Propagate">
          <!-- Both error or success will remove the variables for mock, so it doesn't mess with the next operation in the flow/subflow that are being tested. -->
          <remove-variable
            doc:name="munitHttp"
            variableName="munitHttp" />
          <remove-variable
            doc:name="munitBody"
            variableName="munitBody" />
        </on-error-propagate>
      </error-handler>
    </try>
    <remove-variable
      doc:name="munitHttp"
      variableName="munitHttp" />
    <remove-variable
      doc:name="munitBody"
      variableName="munitBody" />
  </flow>


  <munit:test
    name="impl-test-suite-impl-sub-flowTest"
    timeOut="900000">
    <!-- 5. Critical Step: You must enable the utility flows so they can be discovered and called by the MUnit runtime. -->
    <munit:enable-flow-sources>
      <munit:enable-flow-source
        value="munit-util-mock-http-error.req-based-on-vars.munitHttp" />
      <munit:enable-flow-source
        value="munit-util-mock-http-error.listener" />
    </munit:enable-flow-sources>
    <munit:behavior>
      <!-- -->
      <munit-tools:mock-when
        doc:name="Mock HTTP Req External -&gt; then call flow 400 ;"
        processor="http:request">
        <munit-tools:with-attributes>
          <!-- Identify the specific http:request instance to intercept. -->
          <munit-tools:with-attribute
            whereValue="GET"
            attributeName="method" />
          <munit-tools:with-attribute
            whereValue="http://example.com/external"
            attributeName="url" />
        </munit-tools:with-attributes>
        <munit-tools:then-call
          flow="impl-test-suite.mock-http-req-external-400.flow" />
      </munit-tools:mock-when>
      <!-- -->
      <munit-tools:mock-when
        doc:name="Mock HTTP Req System -&gt; then call flow 503 ;"
        processor="http:request">
        <munit-tools:with-attributes>
          <munit-tools:with-attribute
            whereValue="GET"
            attributeName="method" />
          <munit-tools:with-attribute
            whereValue="http://example.com/system"
            attributeName="url" />
        </munit-tools:with-attributes>
        <!-- 6. Instead of returning a value, instruct the mock to call our setup flow. -->
        <munit-tools:then-call
          flow="impl-test-suite.mock-http-req-system-503.flow" />
      </munit-tools:mock-when>
      <!-- -->
      <munit-tools:spy
        doc:name="Spy HTTP Req System GET /health"
        processor="http:request">
        <munit-tools:with-attributes>
          <munit-tools:with-attribute
            whereValue="GET"
            attributeName="method" />
          <munit-tools:with-attribute
            whereValue="HTTP_Request_configuration_System"
            attributeName="config-ref" />
          <munit-tools:with-attribute
            whereValue="/health"
            attributeName="path" />
        </munit-tools:with-attributes>
      </munit-tools:spy>
      <!-- -->
      <munit-tools:mock-when
        doc:name="Mock HTTP Req Process -&gt; then call flow (default 200) ;"
        processor="http:request">
        <munit-tools:with-attributes>
          <munit-tools:with-attribute
            whereValue="GET"
            attributeName="method" />
          <munit-tools:with-attribute
            whereValue="http://example.com/process"
            attributeName="url" />
        </munit-tools:with-attributes>
        <munit-tools:then-call
          flow="munit-util-mock-http-error.req-based-on-vars.munitHttp" />
      </munit-tools:mock-when>
    </munit:behavior>
    <!-- -->
    <munit:execution>
      <flow-ref
        doc:name="Flow-ref to impl-for-option-a.subflow"
        name="impl-for-option-a" />
    </munit:execution>
    <!-- -->
    <munit:validation>
      <munit-tools:verify-call
        doc:name="ERROR EXCEPTION Req External"
        processor="logger"
        atLeast="1">
        <munit-tools:with-attributes>
          <munit-tools:with-attribute
            whereValue="ERROR EXCEPTION Req External"
            attributeName="doc:name" />
        </munit-tools:with-attributes>
      </munit-tools:verify-call>
      <!-- -->
      <munit-tools:verify-call
        doc:name="ERROR EXCEPTION Req System"
        processor="logger"
        atLeast="1">
        <munit-tools:with-attributes>
          <munit-tools:with-attribute
            whereValue="ERROR EXCEPTION Req System"
            attributeName="doc:name" />
        </munit-tools:with-attributes>
      </munit-tools:verify-call>
      <!-- -->
      <munit-tools:verify-call
        doc:name="3x HTTP Req MUnit Listener"
        processor="http:request"
        times="3">
        <munit-tools:with-attributes>
          <munit-tools:with-attribute
            whereValue="MUnit_HTTP_Request_configuration"
            attributeName="config-ref" />
        </munit-tools:with-attributes>
      </munit-tools:verify-call>
    </munit:validation>
  </munit:test>


  <!-- 7. This flow acts as a test-specific setup, preparing the data for the mock. -->
  <flow name="impl-test-suite.mock-http-req-external-400.flow">
    <ee:transform
      doc:name="munitHttp {queryParams: statusCode: 400 } } ; munitBody ;"
      doc:id="904f4a7e-b23d-4aed-a4e1-f049c97434ef">
      <ee:message></ee:message>
      <ee:variables>
        <!-- This variable will become the body of the error response. -->
        <ee:set-variable variableName="munitBody">
          <![CDATA[%dw 2.0 output application/json --- { message: "Account already exists!" }]]>
        </ee:set-variable>
        <!-- This variable passes the desired status code to the listener via query parameters. -->
        <ee:set-variable variableName="munitHttp">
          <![CDATA[%dw 2.0 output application/java ---
{
  path  : "/",
  method: "GET",
  queryParams: {
    statusCode: 400,
  },
}]]>
        </ee:set-variable>
      </ee:variables>
    </ee:transform>
    <!-- 8. Finally, call the reusable utility flow to trigger the mock listener. -->
    <flow-ref
      doc:name="FlowRef req-based-on-vars.munitHttp-flow"
      name="munit-util-mock-http-error.req-based-on-vars.munitHttp" />
  </flow>


  <flow name="impl-test-suite.mock-http-req-system-503.flow">
    <ee:transform
      doc:name="munitHttp {queryParams: statusCode: 503 } } ; munitBody ;"
      doc:id="de07920c-9cbc-4a52-aa8b-81fe4de93229">
      <ee:message></ee:message>
      <ee:variables>
        <ee:set-variable variableName="munitHttp">
          <![CDATA[%dw 2.0
output application/java
---
{
  path  : "/",
  method: "GET",
  queryParams: {
    statusCode: 503,
  },
}]]>
        </ee:set-variable>
        <ee:set-variable variableName="munitBody">
          <![CDATA[%dw 2.0
output application/json indent=false
---
{
  message: ""
}]]>
        </ee:set-variable>
      </ee:variables>
    </ee:transform>
    <!-- -->
    <flow-ref
      doc:name="FlowRef req-based-on-vars.munitHttp-flow"
      name="munit-util-mock-http-error.req-based-on-vars.munitHttp" />
  </flow>


</mule>